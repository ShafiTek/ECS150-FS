In the last phase, you must implement fs_read() and fs_write() which respectively read from and write to a file.

It is advised to start with fs_read() which is slightly easier to program. You can use the reference program to write a file in a disk image, which you can then read using your implementation.

For these functions, you will probably need a few helper functions. For example, you will need a function that returns the index of the data block corresponding to the file’s offset. For writing, in the case the file has to be extended in size, you will need a function that allocates a new data block and link it at the end of the file’s data block chain. Note that the allocation of new blocks should follow the first-fit strategy (first block available from the beginning of the FAT).

When reading or writing a certain number of bytes from/to a file, you will also need to deal properly with possible “mismatches” between the file’s current offset, the amount of bytes to read/write, the size of blocks, etc.

For example, let’s assume a reading operation for which the file’s offset is not aligned to the beginning of the block or the amount of bytes to read doesn’t span the whole block. You will probably need to read the entire block into a bounce buffer first, and then copy only the right amount of bytes from the bounce buffer into the user-supplied buffer.

The same scenario for a writing operation would slightly trickier. You will probably need to first read the block from disk, then modify only the part starting from the file’s offset with the user-supplied buffer, before you can finally write the dirty block back to the disk.

These special cases happen mostly for small reading/writing operations, or at the beginning or end of a big operation. In big operations (spanning multiple blocks), offsets and sizes are perfectly aligned for all the middle blocks and the procedure is then quite simple, as blocks can be read or written entirely.
